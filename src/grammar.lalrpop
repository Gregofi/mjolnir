use crate::ast::{StmtKind, ExprKind, Stmt, Expr, Location, Decl, DeclKind, Operator, VarDecl, EnumVariant, MatchArm, Pattern};
use crate::frontend::utils::{WeaklyTypedIdentifier, StronglyTypedIdentifier};
use std::str::FromStr;


grammar;

// Lexer
match {
    // TODO: comments

    // keywords
    ";" => SEMICOLON,
    ":" => COLON,
    "_" => UNDERSCORE,
    "&" => AMPER,
    "->" => RIGHT_ARROW,
    "=>" => FAT_RIGHT_ARROW,
    "||" => OR,
    "&&" => AND,
    "="  => ASSIGN,
    "==" => EQ,
    "!=" => NEQ,
    ">"  => GREATER,
    "<"  => LESS,
    ">=" => GREATEREQ,
    "<=" => LESSEQ,
    "*"  => MULTIPLY,
    "/"  => DIVIDE,
    "%"  => MODULO,
    "+"  => PLUS,
    "-" => MINUS,
    "if" => IF,
    "else" => ELSE,
    "(" => LPAREN,
    ")" => RPAREN,
    "let" => LET,
    "[" => LBRACKET,
    "]" => RBRACKET,
    "{" => LBRACE,
    "}" => RBRACE,
    "true" => TRUE,
    "false" => FALSE,
    "fn" => FN,
    "," => COMMA,
    "." => DOT,
    "return" => RETURN,
    "elif" => ELIF,
    "struct" => STRUCT,
    "enum" => ENUM,
    "match" => MATCH,
    "\"" => DOUBLE_QUOTE,
    "'" => SINGLE_QUOTE,

    r"[_A-Za-z][_A-Za-z0-9]*" => IDENTIFIER,
    r"[0-9]+" => NUMBER,
    r#""([^\\"]|\\[~ntr\\"])*""# => STRING_LITERAL,
}

pub TopLevelDecls: Vec<Decl> = {
    <mut v: (<TopLevelDecl>)*> <e: TopLevelDecl> => { v.push(e); v }
}

TopLevelDecl: Decl = {
    FunDecl => <>,
    StructDecl => <>,
    EnumDecl => <>,
}

FunDecl: Decl = {
    <l: @L> FN <name: Identifier> LPAREN <parameters: MaybeTypedIdentifiers> RPAREN <return_type: (COLON <Identifier>)?> ASSIGN <body: Expr> <r: @R> => Decl {
        node: DeclKind::FunDecl{name, parameters, return_type, body: Box::new(body)},
        location: Location::new(l, r),
    }
}

VarDecl: VarDecl = {
    LET <name: Identifier> <return_type: (COLON <Identifier>)?> ASSIGN <value: Expr> => VarDecl {
        name,
        ty: return_type,
        value: Box::new(value),
    }
}

StructDecl: Decl = {
    <l: @L> STRUCT <name: Identifier> LBRACE <fields: TypedIdentifiers> RBRACE <r: @R> => Decl {
        node: DeclKind::StructDecl {
            name,
            fields,
        },
        location: Location::new(l, r),
    }
}

EnumVariant: EnumVariant = {
    <name: Identifier> LPAREN <fields: Identifiers> RPAREN => EnumVariant {
        name,
        fields: fields.into_iter().enumerate().map(|(i, ty)| StronglyTypedIdentifier{name: i.to_string(), ty}).collect(),
    },
    <name: Identifier> => EnumVariant {
        name,
        fields: vec![],
    },
}

EnumVariants: Vec<EnumVariant> = Separated<EnumVariant, COMMA>;

EnumDecl: Decl = {
    <l: @L> ENUM <name: Identifier> LBRACE <variants: EnumVariants> RBRACE <r: @R> => Decl {
        node: DeclKind::EnumDecl {
            name,
            variants,
        },
        location: Location::new(l, r),
    }
}

MaybeTypedIdentifiers: Vec<WeaklyTypedIdentifier> = Separated<MaybeTypedIdentifier, COMMA>;

MaybeTypedIdentifier: WeaklyTypedIdentifier = {
    <name: Identifier> <ty: (COLON <Identifier>)?> => WeaklyTypedIdentifier {
        name,
        ty,
    }
}

TypedIdentifiers: Vec<StronglyTypedIdentifier> = Separated<TypedIdentifier, COMMA>;

TypedIdentifier: StronglyTypedIdentifier = {
    <name: Identifier> COLON <ty: Identifier> => StronglyTypedIdentifier {
        name,
        ty,
    }
}

Identifier: String = IDENTIFIER => <>.to_string();

Separated<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
}

// ==================== Statements ====================


Stmt: Stmt = {
    <l: @L> <decl: VarDecl> <r: @R> => Stmt {
        node: StmtKind::VarDecl(decl),
        location: Location::new(l, r),
    },
    <l: @L> <expr: Expr> <r: @R> => Stmt {
        node: StmtKind::Expr(expr),
        location: Location::new(l, r),
    }
}


// ==================== Expressions ====================

// This rule is pretty stupid, we would want something like
// #[precedence(1)]
// BinOp<Prec1>,
// #[precedence(2)]
// BinOp<Prec2>,
// But that caused conflicts, hence the copy paste.
// Also, the binary operators are converted from string. We would ideally want
// something more "type safe".
Expr: Expr = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec1> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
    #[precedence(level="2")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec2> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
    #[precedence(level="3")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec3> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
}

BinOpPrec1: String = {
    MULTIPLY => <>.to_string(),
    DIVIDE => <>.to_string(),
    MODULO => <>.to_string(),
}

BinOpPrec2: String = {
    PLUS => <>.to_string(),
    MINUS => <>.to_string(),
}

BinOpPrec3: String = {
    EQ => <>.to_string(),
    NEQ => <>.to_string(),
    GREATER => <>.to_string(),
    LESS => <>.to_string(),
    GREATEREQ => <>.to_string(),
    LESSEQ => <>.to_string(),
}

Term: Expr = {
    Number => <>,
    BooleanLit => <>,
    IdentifierExpr => <>,
    FunCallExpr => <>,
    MemberAccessExpr => <>,
    IfExpr => <>,
    Paren => <>,
    Compound => <>,
    Match => <>,
    StructInitializer => <>,
}

Compound: Expr = {
    <l: @L> LBRACE <mut stmts: (<Stmt> SEMICOLON)*> <e: Expr?> RBRACE <r: @R> => {
        let final_expr = match e {
            Some(e) => Box::new(e),
            None => Box::new(Expr {
                location: Location::new(l, r), // Not totaly accurate
                node: ExprKind::Unit,
            })
        };
        Expr {
            node: ExprKind::Compound (
                stmts,
                final_expr,
            ),
            location: Location::new(l, r),
        }
    }
}

Match: Expr = {
    // TODO: We would probably like Expr here instead of Term
    <l: @L> MATCH <target: Term> LBRACE <arms: MatchArms> RBRACE <r: @R> => Expr {
        node: ExprKind::Match {
            target: Box::new(target),
            arms,
        },
        location: Location::new(l, r),
    }
}

MatchArms: Vec<MatchArm<Expr>> = Separated<MatchArm, COMMA>;

MatchArm: MatchArm<Expr> = {
    <pattern: Pattern> <cond: (IF <Expr>)?> FAT_RIGHT_ARROW <body: Expr> => MatchArm {
        pattern,
        cond: match cond {
            Some(c) => Some(Box::new(c)),
            None => None,
        },
        body: Box::new(body),
    }
}

IdentifierList: Vec<String> = Separated<Identifier, COMMA>;

Patterns: Vec<Pattern> = Separated<Pattern, COMMA>;

Pattern: Pattern = {
    UNDERSCORE => Pattern::Wildcard,
    NUMBER => Pattern::Int(i64::from_str(<>).unwrap()),
    TRUE => Pattern::Boolean(true),
    FALSE => Pattern::Boolean(false),
    DOUBLE_QUOTE <id: Identifier> DOUBLE_QUOTE => Pattern::String(id),
    <name: Identifier> LBRACE <fields: IdentifierList> RBRACE => Pattern::Struct {
        name,
        fields,
    },
    <name: Identifier> LPAREN <patterns: Patterns> RPAREN => Pattern::Enum {
        name,
        patterns,
    },
    <name: Identifier> => Pattern::Identifier(name),
}

BooleanLit: Expr = {
    TrueExpr => <>,
    FalseExpr => <>,
}

TrueExpr: Expr = {
    <l: @L> TRUE <r: @R> => Expr {
        node: ExprKind::Boolean(true),
        location: Location::new(l, r),
    },
}

FalseExpr: Expr = {
    <l: @L> FALSE <r: @R> => Expr {
        node: ExprKind::Boolean(false),
        location: Location::new(l, r),
    },
}

Paren: Expr = {
    <l: @L> LPAREN <expr: Expr> RPAREN <r: @R> => expr,
}

MemberAccessExpr: Expr = {
    <l: @L> <target: Term> DOT <member: Identifier> <r: @R> => Expr {
        node: ExprKind::MemberAccess {
            target: Box::new(target),
            member
        },
        location: Location::new(l, r),
    }
}

FunCallExpr: Expr = {
    <l: @L> <target: Term> LPAREN <args: Arguments> RPAREN <r: @R> => Expr {
        node: ExprKind::FunCall{target: Box::new(target), args},
        location: Location::new(l, r),
    }
}

Arguments: Vec<Expr> = Separated<Expr, COMMA>;

IfExpr: Expr = {
    <l: @L> IF <cond: Expr> LBRACE <then: Expr> RBRACE ELSE LBRACE <els: Expr> RBRACE <r: @R> => Expr {
        node: ExprKind::If { cond: Box::new(cond), then: Box::new(then), els: Box::new(els) },
        location: Location::new(l, r),
    }
}

IdentifierExpr: Expr = {
    <l: @L> <id: Identifier> <r: @R> => Expr {
        node: ExprKind::Identifier(id),
        location: Location::new(l, r),
    }
}

Number: Expr = {
    <l: @L> <n: NUMBER> <r: @R> => Expr {
        node: ExprKind::Int(i64::from_str(n).unwrap()),
        location: Location::new(l, r),
    }
}

IdentifierMapping: (String, Expr) = {
    <ident: Identifier> COLON <expr: Expr> => (ident, expr),
}

IdentifiersMapping: Vec<(String, Expr)> = Separated<IdentifierMapping, COMMA>;

Identifiers: Vec<String> = Separated<Identifier, COMMA>;

StructInitializer: Expr = {
    // TODO: This amber is here cause otherwise there is a conflict.
    <l: @L> AMPER <name: Identifier> LBRACE <fields: IdentifiersMapping> RBRACE <r: @R> => Expr {
        node: ExprKind::StructInitializer {
            name,
            fields,
        },
        location: Location::new(l, r),
    }
}
