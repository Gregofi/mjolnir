use crate::ast::{StmtKind, ExprKind, Stmt, Expr, Location, Decl, DeclKind, Operator, VarDecl};
use crate::frontend::utils::WeaklyTypedIdentifier;
use std::str::FromStr;


grammar;

// Lexer
match {
    // TODO: comments

    // keywords
    ";" => SEMICOLON,
    ":" => COLON,
    "->" => RIGHT_ARROW,
    "=>" => FAT_RIGHT_ARROW,
    "||" => OR,
    "&&" => AND,
    "="  => ASSIGN,
    "==" => EQ,
    "!=" => NEQ,
    ">"  => GREATER,
    "<"  => LESS,
    ">=" => GREATEREQ,
    "<=" => LESSEQ,
    "*"  => MULTIPLY,
    "/"  => DIVIDE,
    "%"  => MODULO,
    "+"  => PLUS,
    "-" => MINUS,
    "if" => IF,
    "else" => ELSE,
    "(" => LPAREN,
    ")" => RPAREN,
    "let" => LET,
    "[" => LBRACKET,
    "]" => RBRACKET,
    "{" => LBRACE,
    "}" => RBRACE,
    "true" => TRUE,
    "false" => FALSE,
    "fn" => FN,
    "," => COMMA,
    "." => DOT,
    "return" => RETURN,
    "elif" => ELIF,

    r"[_A-Za-z][_A-Za-z0-9]*" => IDENTIFIER,
    r"[0-9]+" => NUMBER,
    r#""([^\\"]|\\[~ntr\\"])*""# => STRING_LITERAL,
}

pub TopLevelDecls: Vec<Decl> = {
    <mut v: (<TopLevelDecl>)*> <e: TopLevelDecl> => { v.push(e); v }
}

TopLevelDecl: Decl = {
    FunDecl => <>,
}

FunDecl: Decl = {
    <l: @L> FN <name: Identifier> LPAREN <parameters: MaybeTypedIdentifiers> RPAREN <return_type: (COLON <Identifier>)?> ASSIGN <body: Expr> <r: @R> => Decl {
        node: DeclKind::FunDecl{name, parameters, return_type, body: Box::new(body)},
        location: Location::new(l, r),
    }
}

VarDecl: VarDecl = {
    LET <name: Identifier> <return_type: (COLON <Identifier>)?> ASSIGN <value: Expr> => VarDecl {
        name,
        ty: return_type,
        value: Box::new(value),
    }
}

MaybeTypedIdentifiers: Vec<WeaklyTypedIdentifier> = Separated<MaybeTypedIdentifier, COMMA>;

MaybeTypedIdentifier: WeaklyTypedIdentifier = {
    <name: Identifier> <ty: (COLON <Identifier>)?> => WeaklyTypedIdentifier {
        name,
        ty,
    }
}

Identifier: String = IDENTIFIER => <>.to_string();

Separated<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T?> => match e {
        None => v,
        Some(e) => { v.push(e); v }
    }
}

// ==================== Statements ====================


Stmt: Stmt = {
    <l: @L> <decl: VarDecl> <r: @R> => Stmt {
        node: StmtKind::VarDecl(decl),
        location: Location::new(l, r),
    },
    <l: @L> <expr: Expr> <r: @R> => Stmt {
        node: StmtKind::Expr(expr),
        location: Location::new(l, r),
    }
}


// ==================== Expressions ====================

// This rule is pretty stupid, we would want something like
// #[precedence(1)]
// BinOp<Prec1>,
// #[precedence(2)]
// BinOp<Prec2>,
// But that caused conflicts, hence the copy paste.
// Also, the binary operators are converted from string. We would ideally want
// something more "type safe".
Expr: Expr = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec1> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
    #[precedence(level="2")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec2> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
    #[precedence(level="3")] #[assoc(side="left")]
    <l: @L> <lhs: Expr> <opcode: BinOpPrec3> <rhs: Expr> <r: @R> => {
        Expr {
            node: ExprKind::Binary{op: Operator::from(opcode.as_str()), lhs: Box::new(lhs), rhs: Box::new(rhs)},
            location: Location::new(l, r),
        }
    },
}

BinOpPrec1: String = {
    MULTIPLY => <>.to_string(),
    DIVIDE => <>.to_string(),
    MODULO => <>.to_string(),
}

BinOpPrec2: String = {
    PLUS => <>.to_string(),
    MINUS => <>.to_string(),
}

BinOpPrec3: String = {
    EQ => <>.to_string(),
    NEQ => <>.to_string(),
    GREATER => <>.to_string(),
    LESS => <>.to_string(),
    GREATEREQ => <>.to_string(),
    LESSEQ => <>.to_string(),
}

Term: Expr = {
    Number => <>,
    BooleanLit => <>,
    IdentifierExpr => <>,
    FunCallExpr => <>,
    IfExpr => <>,
    Paren => <>,
    Compound => <>,
}

Compound: Expr = {
    <l: @L> LBRACE <mut stmts: (<Stmt> SEMICOLON)*> <e: Expr?> RBRACE <r: @R> => {
        let final_expr = match e {
            Some(e) => Box::new(e),
            None => Box::new(Expr {
                location: Location::new(l, r), // Not totaly accurate
                node: ExprKind::Unit,
            })
        };
        Expr {
            node: ExprKind::Compound (
                stmts,
                final_expr,
            ),
            location: Location::new(l, r),
        }
    }
}

BooleanLit: Expr = {
    TrueExpr => <>,
    FalseExpr => <>,
}

TrueExpr: Expr = {
    <l: @L> TRUE <r: @R> => Expr {
        node: ExprKind::Boolean(true),
        location: Location::new(l, r),
    },
}

FalseExpr: Expr = {
    <l: @L> FALSE <r: @R> => Expr {
        node: ExprKind::Boolean(false),
        location: Location::new(l, r),
    },
}

Paren: Expr = {
    <l: @L> LPAREN <expr: Expr> RPAREN <r: @R> => expr,
}

FunCallExpr: Expr = {
    <l: @L> <target: Term> LPAREN <args: Arguments> RPAREN <r: @R> => Expr {
        node: ExprKind::FunCall{target: Box::new(target), args},
        location: Location::new(l, r),
    }
}

Arguments: Vec<Expr> = Separated<Expr, COMMA>;

IfExpr: Expr = {
    <l: @L> IF <cond: Expr> LBRACE <then: Expr> RBRACE ELSE LBRACE <els: Expr> RBRACE <r: @R> => Expr {
        node: ExprKind::If { cond: Box::new(cond), then: Box::new(then), els: Box::new(els) },
        location: Location::new(l, r),
    }
}

IdentifierExpr: Expr = {
    <l: @L> <id: Identifier> <r: @R> => Expr {
        node: ExprKind::Identifier(id),
        location: Location::new(l, r),
    }
}

Number: Expr = {
    <l: @L> <n: NUMBER> <r: @R> => Expr {
        node: ExprKind::Int(i64::from_str(n).unwrap()),
        location: Location::new(l, r),
    }
}

